#!/usr/bin/env -S csi -ss

;;; Prints stats on https://ecraven.github.io/r7rs-benchmarks/

(import (chicken base)
	(chicken format)
	(chicken io)
	(chicken port)
	(chicken pretty-print)
	(chicken process-context)
	(chicken sort)
	(chicken string)
	srfi-1)

(define timeout-string "ULIMITKILLED")

(define (main _)
  ;; Program entry point.
  (let ((args (command-line-arguments)))
    (if (null? args)
	(usage)
	(let* ((path (car args))
	       (records (call-with-input-file path read-csv)))
	  (analyze (clean-fields records) (cdr args))))))

(define (read-csv port)
  ;; Read a CSV file from port, returning a list of lists of strings.
  (define (read-csv-record line)
    (string-split line "," #t))
  (let loop ((lst '()))
    (let ((line (read-line port)))
      (if (eof-object? line)
	  lst
	  (loop (cons (read-csv-record line) lst))))))

(define (clean-fields records)
  ;; Remove extraneous information from CSV fields.
  (map (lambda (rec)
	 (list (strip-suffix "-" (first rec))
	       (strip-suffix ":" (second rec))
	       (third rec)))
       records))

(define (strip-suffix delim field)
  ;; Strip the version suffix from a field.
  (first (string-split field delim)))

(define (analyze records implementations)
  ;; Analyze the data in records for the given implementations.
  (define all-implementations (delete-duplicates (map first records)))
  (if (null? implementations)
      (set! implementations all-implementations))
  (let* ((records (filter (lambda (rec)
			    (any (lambda (imp)
				   (string=? imp (first rec)))
				 implementations))
			  records))
	 (records-by-imp (map (lambda (imp)
				(cons imp (filter (lambda (rec)
						    (string=? imp (first rec)))
						  records)))
			      implementations)))
    (define (imp-errors imp)
      (length (filter (lambda (rec)
			(and (not (string->number (third rec)))
			     (not (string=? timeout-string (third rec)))))
		      (alist-ref imp records-by-imp))))
    (define (imp-timeouts imp)
      (length (filter (lambda (rec)
			(string=? timeout-string (third rec)))
		      (alist-ref imp records-by-imp))))
    (define (imp-completed-tests imp)
      (map second (filter (lambda (rec)
			    (string->number (third rec)))
			  (alist-ref imp records-by-imp))))
    (define (imp-relative-time imp)
      (let ((tests (imp-completed-tests imp)))
	(/ (imp-total-time imp tests)
	   (first (sort (filter identity (map (lambda (imp)
						(imp-total-time imp tests))
					      all-implementations))
			<)))))
    (define (imp-total-time imp tests)
      (let ((times (map (compose string->number third)
			(filter (lambda (rec)
				  (member (second rec) tests))
				(alist-ref imp records-by-imp)))))
	(if (any not times)
	    #f
	    (apply + times))))
    (define (results proc)
      (sort (map (lambda (imp)
		   (list imp (proc imp)))
		 implementations)
	    (lambda (x y)
	      (< (second x) (second y)))))
    (pp `((errors ,@(results imp-errors))
	  (timeouts ,@(results imp-timeouts))
	  (relative-time ,@(results imp-relative-time))))))

(define (usage)
  ;; Print CLI usage instructions.
  (with-output-to-port (current-error-port)
    (lambda ()
      (print "usage: r7rs-benchmark-stats <input.csv> <implementation> ...")))
  (exit 1))
